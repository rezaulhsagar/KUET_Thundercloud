int m, n, deg[MM], source, sink, K, val[MM][12];
struct edge {
	int v, w;
}adj[MM][500];
struct info {
	int v, w, k;
	bool operator < ( const info &b ) const {
		return w > b.w;
	}
};
priority_queue < info, vector <info> > Q;
void kthBestShortestPath() {
	int i, j;
	info u, v;
	for( i = 0; i < n; i++ ) for( j = 0; j < K; j++ ) val[i][j] = inf;
	u.v = source; u.k = 0; u.w = 0;
	Q.push(u);
	while( !Q.empty() ) {
		u = Q.top();
		Q.pop();
		for( i = 0; i < deg[u.v]; i++ ) {
			v.v = adj[u.v][i].v;
			int cost = adj[u.v][i].w + u.w;
			for( v.k = u.k; v.k < K; v.k++ ) {
				if( cost == inf ) break;
				if( val[v.v][v.k] > cost ) {
					swap( cost, val[v.v][v.k] );
					v.w = val[v.v][v.k];
					Q.push(v);
					break;
				}
			}
			for( v.k++; v.k < K; v.k++ ) {
				if( cost == inf ) break;
				if( val[v.v][v.k] > cost ) swap( cost, val[v.v][v.k] );
			}
		}
	}
}
